# /etc/nginx/nginx.conf
user  root;
worker_processes  auto;

error_log /dev/stderr info;
pid        /var/run/nginx.pid;

events {
  worker_connections  4096;
  multi_accept on;
}

http {
  include       mime.types;
  default_type  application/octet-stream;

  # Tuning umum
  sendfile        on;
  tcp_nopush      on;
  tcp_nodelay     on;
  keepalive_timeout  65;
  types_hash_max_size 4096;

  # Log
  # access_log /dev/stdout combined;

  # ===== Shared dict untuk modul Lua =====
  lua_shared_dict domains_shdict 10m;   # cache domains.json (domain -> pool)
  lua_shared_dict pools_shdict   10m;   # cache pools.json (pool -> servers)
  lua_shared_dict conn_shdict    10m;   # counter koneksi per node
  lua_shared_dict health_shdict  10m;   # (opsional) untuk healthcheck

  # ===== Init Worker: muat data & hot-reload berkala =====
  init_worker_by_lua_block {
    local ok, err
    local domain_loader = require "domain_loader"
    local pools = require "pools"

    ok, err = pools.load_pools("/etc/nginx/pools.json")
    if not ok then ngx.log(ngx.ERR, "pools load error: ", err or "?") end

    ok, err = domain_loader.load_domains("/etc/nginx/domains.json")
    if not ok then ngx.log(ngx.ERR, "domains load error: ", err or "?") end

    -- (opsional) mulai health check di background
    if pools.start_health_checks then pools.start_health_checks() end

    -- Hot reload file tiap 5 detik (ringan)
    local function refresh(premature)
      if premature then return end
      pools.load_pools("/etc/nginx/pools.json")
      domain_loader.load_domains("/etc/nginx/domains.json")
      local timer_at = ngx.timer.at
      timer_at(5, refresh)
    end
    ngx.timer.at(5, refresh)
  }

  # =======================
  #        PORT 80
  # =======================
  server {
    listen 80 default_server;
    server_name _ localhost;

    # ACME (HTTP-01)
    location ^~ /.well-known/acme-challenge/ {
      root /var/www/certbot;
      allow all;
      try_files $uri =404;
    }

    # API add-domain (Flask kamu di 127.0.0.1:5000)
    location /api/add-domain {
      proxy_pass http://127.0.0.1:5000;
      proxy_http_version 1.1;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

    # Router + Balancer (HTTP)
    # - access_by_lua*: tentukan pool berdasarkan Host
    # - balancer_by_lua*: pilih node least-connections dari pool
    access_by_lua_block {
      local router = require "router"
      router()  -- set ngx.ctx.selected_pool
    }

    balancer_by_lua_block {
      local lb = require "balancer"
      lb.balance()  -- pilih peer & set_current_peer
    }

    # proxy_pass "placeholder"; peer sesungguhnya diset oleh balancer_by_lua
    location / {
      proxy_pass http://0.0.0.0;  # host/port di-override balancer.set_current_peer
      proxy_http_version 1.1;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_buffers 64 32k;
      proxy_busy_buffers_size 64k;
    }

    # Kurangi counter koneksi setelah request selesai
    log_by_lua_block {
      local lb = require "balancer"
      local h, p = ngx.ctx.lb_host, ngx.ctx.lb_port
      if h and p then
        lb.dec_conn(h, p)
      end
    }
  }

  # =======================
  #        PORT 443
  # =======================
  server {
    listen 443 ssl http2 default_server;
    server_name _;

    # Fallback dummy cert â€” akan di-override di handshake jika LE tersedia
    ssl_certificate     /etc/nginx/ssl/dummy.crt;
    ssl_certificate_key /etc/nginx/ssl/dummy.key;

    # Pilih sertifikat berdasarkan SNI dari hasil Certbot
    ssl_certificate_by_lua_block {
      local ssl = require("ngx.ssl")
      local domain = ssl.server_name()
      if not domain or domain == "" then
        ngx.log(ngx.WARN, "No SNI; using dummy cert")
        return
      end
      local cert_path = "/var/lib/certbot/live/" .. domain .. "/fullchain.pem"
      local key_path  = "/var/lib/certbot/live/" .. domain .. "/privkey.pem"

      local fc = io.open(cert_path, "r")
      local fk = io.open(key_path, "r")
      if not fc or not fk then
        ngx.log(ngx.WARN, "SSL not found for " .. domain .. "; using dummy cert")
        if fc then fc:close() end
        if fk then fk:close() end
        return
      end

      local cert = fc:read("*a"); fc:close()
      local key  = fk:read("*a"); fk:close()

      assert(ssl.clear_certs())
      assert(ssl.set_der_cert(ssl.cert_pem_to_der(cert)))
      assert(ssl.set_der_priv_key(ssl.priv_key_pem_to_der(key)))
    }

    # ACME path tetap dibuka (beberapa klien salah tembak ke 443)
    location ^~ /.well-known/acme-challenge/ {
      root /var/www/certbot;
      allow all;
      try_files $uri =404;
    }

    # Router + Balancer (HTTPS)
    access_by_lua_block {
      local router = require "router"
      router()
    }

    balancer_by_lua_block {
      local lb = require "balancer"
      lb.balance()
    }

    location / {
      proxy_pass http://0.0.0.0;  # di-override oleh balancer
      proxy_http_version 1.1;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-Proto https;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_buffers 64 32k;
      proxy_busy_buffers_size 64k;
    }

    log_by_lua_block {
      local lb = require "balancer"
      local h, p = ngx.ctx.lb_host, ngx.ctx.lb_port
      if h and p then
        lb.dec_conn(h, p)
      end
    }
  }

  # (Opsional) blok khusus untuk *.isipage.com pakai cert statis
  server {
    listen 443 ssl http2;
    server_name ~^(?<subdomain>.+)\.isipage\.com$;
    ssl_certificate     /etc/nginx/ssl/isipage.crt;
    ssl_certificate_key /etc/nginx/ssl/isipage.key;
  
    access_by_lua_block { local router = require "router"; router() }
    balancer_by_lua_block { local lb = require "balancer"; lb.balance() }
    location / { proxy_pass http://0.0.0.0; proxy_set_header Host $host; }
    log_by_lua_block { local lb=require"balancer"; if ngx.ctx.lb_host then lb.dec_conn(ngx.ctx.lb_host, ngx.ctx.lb_port) end }
  }
}
